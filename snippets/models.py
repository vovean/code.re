import uuid
from string import ascii_lowercase

from django.db import models
from django.db.models import TextChoices
from django.db.models.functions import Length
from django.utils.crypto import get_random_string

models.CharField.register_lookup(Length)


class SnippetManager(models.Manager):
    def generate_short_link(self):
        last_short_link = self._get_last_short_link()
        new_link_num = ((
                                (ord(last_short_link[2]) - ord('a')) * 26 ** 0 +
                                (ord(last_short_link[1]) - ord('a')) * 26 ** 1 +
                                (ord(last_short_link[0]) - ord('a')) * 26 ** 2
                        ) + 1) % (26 ** 3)
        singles = new_link_num % 26
        tens = new_link_num // 26 % 26
        hundreds = new_link_num // 26 // 26
        return f"{ascii_lowercase[hundreds]}{ascii_lowercase[tens]}{ascii_lowercase[singles]}"

    def _get_last_short_link(self):
        last_short_link_snippet = self.filter(link__length=3)
        if not last_short_link_snippet.exists():
            return "aaa"
        last_short_link = last_short_link_snippet.last().link
        # so we never get "api" link which collides with /api routing
        if last_short_link == "aph":
            last_short_link = "api"
        return last_short_link

    def create(self, **kwargs):
        if 'link' in kwargs:
            raise Exception("link is autogenerated and cannot be set manually")
        link_mode = kwargs.pop('link_mode', "short")
        if link_mode == "short":
            kwargs["link"] = self.generate_short_link()
        elif link_mode == "long":
            kwargs["link"] = self.generate_long_link()
        else:
            raise Exception(f"Invalid link mode: {link_mode}")

        return super().create(**kwargs)

    def change_link_mode_for(self, snippet: "Snippet"):
        if len(snippet.link) == 3:
            snippet.link = self.generate_long_link()
        else:
            snippet.link = self.generate_short_link()
        snippet.save()

    def generate_long_link(self):
        link = get_random_string(length=8)
        while self.filter(link=link).exists():
            link = get_random_string(length=8)
        return link


class Snippet(models.Model):
    class SyntaxChoices(TextChoices):
        CSRC = 'C'
        CPPSRC = 'CPP'
        CSHARP = 'C#'
        CSS = 'CSS'
        COMMON_LISP = 'Common Lisp'
        DOCKERFILE = 'Dockerfile'
        ERLANG = 'Erlang'
        GO = 'GO'
        GROOVY = 'Groovy'
        HASKELL = 'Haskell'
        HTML = 'HTML'
        JAVA = 'Java'
        JAVASCRIPT = 'JavaScript'
        JSON = 'JSON'
        TYPESCRIPT = 'TypeScript'
        KOTLIN = 'Kotlin'
        LUA = 'Lua'
        MARKDOWN = 'Markdown'
        OBJECTIVEC = 'Objective C'
        PASCAL = 'Pascal'
        PERL = 'Perl'
        PHP = 'PHP'
        POWERSHELL = 'PowerShell'
        PROTOBUF = 'ProtoBuf'
        PYTHON = 'Python'
        RSRC = 'R'
        RUBY = 'Ruby'
        RST = 'reStructuredText'
        RUSTSRC = 'Rust'
        SASS = 'Sass'
        SCALA = 'Scala'
        SCSS = 'SCSS'
        SH = 'Shell'
        SWIFT = 'Swift'
        SQL = 'SQL'
        STEX = 'LaTeX'
        TOML = 'TOML'
        VB = 'VB.NET'
        VUE = 'Vue.js app'
        XML = 'XML'
        WEBASSEMBLY = 'WebAssembly Text Format'
        YAML = 'YAML'

    objects = SnippetManager()

    created_at = models.DateTimeField(auto_now_add=True)
    token = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    syntax = models.CharField(max_length=20, choices=SyntaxChoices.choices)
    code = models.TextField()
    link = models.CharField(max_length=8, unique=True)

    def as_dict(self):
        return {
            "code": self.code,
            "syntax": self.syntax,
            "link": self.link
        }
